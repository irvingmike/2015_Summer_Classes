<?xml version="1.0"?>
<!DOCTYPE TEI.2 PUBLIC "-//TEI//DTD TEI Lite XML ver. 1.1//EN" "http://www.tei-c.org/Lite/DTD/teixlite.dtd">

<TEI.2>
<teiHeader>
<fileDesc>
<titleStmt>
<title>A Gentle Introduction to XML</title>
<author>(extracted from <emph>TEI P4:
Guidelines for Electronic Text Encoding and Interchange
            (XML-compatible edition)</emph>)</author>
</titleStmt>
<editionStmt>
<edition>
<date>May 2002</date>
</edition>
</editionStmt>
<publicationStmt>
<p/>
</publicationStmt>
<sourceDesc>
<p>copied from bits of driver.xml for P4</p>
</sourceDesc>
</fileDesc>
<profileDesc>
<langUsage>
<language id="sgml">Examples in p2ch use this</language>
<language id="LA">Latin, I expect</language>
</langUsage>
</profileDesc>
</teiHeader>
<text>
<body>
<div type="Chapter" id="SG"><head>A Gentle Introduction to XML</head>

<note place="divtop">As originally published in previous editions of the
<title>Guidelines</title>, this chapter provided a
gentle introduction to <soCalled>just enough</soCalled> SGML for
anyone to understand how the TEI used that standard. Since then, the
<title>Gentle Guide</title> seems to have taken on a life of its own
independent of the Guidelines, having been widely distributed (and
flatteringly imitated) on the web. In revising it for the present
draft, the editors have therefore felt free to reduce considerably its
discussion of SGML-specific matters, in favour of a simple
presentation of how the TEI uses XML.</note>

<p>The encoding scheme defined by these Guidelines may be formulated
either as an application of the ISO Standard Generalized Markup
Language (SGML)<note place="foot">International Organization for
Standardization, <title>ISO 8879: Information processing &#x2013; Text
and office systems &#x2013; Standard Generalized Markup Language
(SGML),</title> ([Geneva]: ISO, 1986).
</note> or of the more recently developed W3C Extensible Markup
Language (XML)<note place="foot">World Wide Web Consortium:
<title>Extensible Markup Language (XML) 1.0</title>, available from
<xptr doc="XMLspec"/></note>. Both SGML
and XML are widely-used for the definition of device-independent,
system-independent methods of storing and processing texts in
electronic form; XML being in fact a simplification or derivation of
SGML.  In the present chapter we introduce informally the basic
concepts underlying such markup languages and attempt to explain to
the reader encountering them for the first time how they are actually
used in the TEI scheme. Except where the two are explicitly
distinguished, references to XML in what follows may be understood to
apply equally well to the TEI usage of SGML. For a more technical
account of TEI practice see chapter 28 of the TEI Guidelines; for a more
technical description of the subset of SGML used by the TEI encoding
scheme, see chapter 39 of the TEI Guidelines.</p>

<p>XML is an extensible markup language used for the description of
marked-up electronic text.  More exactly, XML is a
<term>metalanguage</term>, that is, a means of formally describing a
language, in this case, a <term>markup</term> language.  Historically,
the word <term>markup</term> has been used to describe annotation or
other marks within a text intended to instruct a compositor or typist
how a particular passage should be printed or laid out.  Examples
include wavy underlining to indicate boldface, special symbols for
passages to be omitted or printed in a particular font and so forth.
As the formatting and printing of texts was automated, the term was
extended to cover all sorts of special codes inserted into electronic
texts to govern formatting, printing, or other processing.</p>

<p>Generalizing from that sense, we define markup, or (synonymously)
<term>encoding</term>, as any means of making explicit an
interpretation of a text.  Of course, all printed texts are
implicitly encoded (or marked up) in this sense: punctuation marks, use of capitalization,
disposition of letters around the page, even the spaces between words,
might be regarded as a kind of markup, the function of which is to
help the human reader determine where one word ends and another
begins, or how to identify gross structural features such as headings
or simple syntactic units such as dependent clauses or sentences.
Encoding a text for computer processing is in principle, like
transcribing a manuscript from <foreign lang="LA">scriptio
continua</foreign>,<note place="foot">In the <q>continuous writing</q>
characteristic of manuscripts from the early classical period, words
are written continuously with no intervening spaces or
punctuation.</note> a process of making explicit what is conjectural
or implicit, a process of directing the user as to how the content of
the text should be (or has been) interpreted.</p> <p>By <term>markup
language</term> we mean a set of markup conventions used together for
encoding texts.  A markup language must specify what markup is
allowed, what markup is required, how markup is to be distinguished
from text, and what the markup means.  XML provides the means for
doing the first three; documentation such as these Guidelines is
required for the last.</p>

<p>The present chapter attempts to give an informal introduction to
those parts of XML of which a proper understanding is necessary to
make best use of these Guidelines. The interested reader should also
consult one or more of the dozens of excellent introductory text books
or web sites now available on the subject. </p>

<div id="SG11"><head>What's special about XML?</head>

<p>Three characteristics of XML seem to us to make it unlike other
other markup languages: 
<list>
<item>its emphasis on descriptive rather than
procedural markup;</item>
<item> its <term>document type</term> concept; </item>
<item>its
independence of any one hardware or software system.</item></list>
These three
aspects are discussed briefly below, and then in more depth in
sections <ptr target="SG13"/> and <ptr target="SG17"/>.</p>

<p>The markup language with which XML is most frequently compared,
   however, is HTML, the language in which web pages had always been
   written until XML began to replace it. Compared with HTML, XML has
   some other important characteristics:
<list><item>XML is extensible: it does not contain a fixed set of
   tags</item>
<item>XML documents must be well-formed according to a defined syntax, 
and may be formally  validated</item>
<item>XML focuses on the meaning of data, not its presentation</item>
   </list>
  </p>

<div type="burp" id="SG111"><head>Descriptive markup</head>

<p>In a descriptive markup system, the markup codes used do little
more than categorize parts of a document.  Markup codes such as
<code>&lt;para&gt;</code> or <code>\end{list}</code> simply identify a portion
of a document and assert of it that <q>the following item is a
paragraph,</q> or <q>this is the end of the most recently begun
list,</q> etc.  By contrast, a procedural markup system defines what
processing is to be carried out at particular points in a document:
<q>call procedure PARA with parameters 1, b and x here</q> or <q>move
the left margin 2 quads left, move the right margin 2 quads right,
skip down one line, and go to the new left margin,</q> etc.  In XML,
the instructions needed to process a document for some particular
purpose (for example, to format it) are sharply distinguished from the
descriptive markup which occurs within the document.  They are
collected outside the document in separate procedures or programs, and
are usually expressed in a distinct document called a
<term>stylesheet</term>, though it may do much more than simply define
the rendition or visual appearance of a document.<note place="foot">We do not here discuss in any detail the ways that a
   style sheet can be used  or defined, nor do we discuss the
   increasingly popular W3C  Stylesheet
		  Languages. See <xptr doc="XSL"/> for the Extensible
		  Stylesheet Language (XSL), and <xptr doc="XSLT"/> for
   the XSL Transformations (XSLT) Language.</note></p> 

<p>With descriptive instead of procedural markup the same document can
readily be processed in many different ways, using only those parts of
it which are considered relevant.  For example, a content analysis
program might disregard entirely the footnotes embedded in an
annotated text, while a formatting program might extract and collect
them all together for printing at the end of each chapter. Different
kinds of processing can be carried out with the same part of a file.
For example, one program might extract names of persons and places
from a document to create an index or database, while another,
operating on the same text, but using a different stylesheet, might
print names of persons and places in a distinctive typeface.</p>
</div>

<div type="burp" id="SG112">
<head>Types of document</head> 

<p>A second key aspect of XML is its notion of a <term>document
type</term>:  documents are regarded as having types, just as other objects
processed by computers do.  The type of a document is formally defined
by its constituent parts and their structure.  The definition of a
<soCalled>report</soCalled>, for example, might be that it consisted
of a <soCalled>title</soCalled> and possibly an
<soCalled>author</soCalled>, followed by an
<soCalled>abstract</soCalled> and a sequence of one or more
<soCalled>paragraphs</soCalled>.  Anything lacking a title, according
to this formal definition, would not formally be a report, and neither
would a sequence of paragraphs followed by an abstract, whatever other
report-like characteristics these might have for the human reader.</p>

<p>If documents are of known types, a special purpose program (called
a <term>parser</term>), once provided with an unambiguous definition
of a document's type, can check that any  document claiming to be of a
that type does in fact conform to the specification. A parser
can check that all and only elements specified for a particular
document type are present, that they are combined in appropriate ways,
correctly ordered and so forth.  More significantly, different
documents of the same type can be processed in a uniform way. Programs
can be written which take advantage of the knowledge encapsulated in
the document structure information, and which can thus behave in a
more <soCalled>intelligent</soCalled> fashion.</p></div>

<div type="burp" id="SG113"><head>Data independence</head>

	  <p>A basic design goal of XML is to ensure that documents
		encoded according to its provisions can move from one
		hardware and software environment to another without
		loss of information. The two features discussed so far
		both address this requirement at an abstract level;
		the third feature addresses it at the level of the
		strings of data characters of which documents are
		composed.  All XML documents, whatever language or
		writing system they employ, use the same underlying
		character encoding (that is, the same method of
		representing the graphic forms making up a particular
		writing system as binary data).<note place="foot">See
		<title>Extensible Markup Language (XML) 1.0</title>,
		Section 2.2 Characters.</note> This encoding is
		defined by an international standard,<note place="foot">ISO/IEC 10646-1993 <title>Information
		Technology &#x2014; Universal Multiple-Octed Coded
		Character Set</title> (UCS)</note> which is
		implemented by a universal character set maintained by
		an industry group called the Unicode Consortium, and
		known as Unicode;<note place="foot">See <xptr doc="Unicode"/></note> this provides a standardised
		way of representing any of the thousands of discrete
		symbols making up the world's writing systems, past
		and present.</p>

<p>For technical and historical reasons which need not concern us, it
is often necessary to translate texts encoded as Unicode into some
smaller or less general encoding scheme. XML uses a general purpose
<term>string substitution</term> mechanism for this purpose, inherited
from SGML (which predates the availability of Unicode). In simple
terms, this mechanism allows for the indirect representation of
arbitrary parts of a document (be they single characters, character
strings, or whole files) within it. One obvious application for this
mechanism is to ensure consistency of nomenclature; another, more
significant one, is to counter the notorious inability of different
computer systems to understand each other's character sets, or of any
one system to provide all the graphic characters needed for a
particular application. The strings defined by this
string-substitution mechanism are called <term>entities</term> and
they are discussed below in section <ptr target="SG17"/>.</p></div></div>

<div id="SG12"><head>Textual structure</head>
<p>A text is not an undifferentiated sequence of words, much less of
bytes. For different purposes, it may be divided into many different
units, of different types or sizes.  A prose text such as this one
might be divided into sections, chapters, paragraphs, and sentences.  A
verse text might be divided into cantos, stanzas, and lines.  Once
printed, sequences of prose and verse might be divided into volumes,
gatherings, and pages.</p>

<p>Structural units of this kind are most often used to identify
specific locations or reference points within a text (<q>the third
sentence of the second paragraph in chapter ten</q>; <q>canto 10, line
1234</q>; <q>page 412,</q> etc.) but they may also be used to
subdivide a text into meaningful fragments for analytic purposes
(<q>is the average sentence length of section 2 different from that of
section 5?</q> <q>how many paragraphs separate each occurrence of the
word <mentioned>nature</mentioned>?</q> <q>how many pages?</q>).
Other structural units are more clearly analytic, in that they
characterize a section of a text.  A dramatic text might regard each
speech by a different character as a unit of one kind, and stage
directions or pieces of action as units of another kind.  Such an
analysis is less useful for locating parts of the text (<q>the 93rd
speech by Horatio in Act 2</q>) than for facilitating comparisons
between the words used by one character and those of another, or those
used by the same character at different points of the play.</p>

<p>In a prose text one might similarly wish to regard as units of
different types passages in direct or indirect speech, passages
employing different stylistic registers (narrative, polemic,
commentary, argument, etc.), passages of different authorship and so
forth.  And for certain types of analysis (most notably textual
criticism) the physical appearance of one particular printed or
manuscript source may be of importance:  paradoxically, one may wish to
use descriptive markup to describe presentational features such as
typeface, line breaks, use of whitespace and so forth.</p>

<p>These textual structures overlap with each other in complex and
unpredictable ways.  Particularly when dealing with texts as
instantiated by paper technology, the reader needs to be aware of both
the physical organization of the book and the logical structure of the
work it contains.  Many great works (Sterne's <title>Tristram
Shandy</title> for example) cannot be fully appreciated without an
awareness of the interplay between narrative units (such as chapters or
paragraphs) and page divisions.  For many types of research, it is the
interplay between different levels of analysis which is crucial:  the
extent to which syntactic structure and narrative structure mesh, or
fail to mesh, for example, or the extent to which phonological
structures reflect morphology.</p></div>

<div id="SG13"><head>XML structures</head>

<p>This section describes the simple and consistent mechanism for the
markup or identification of textual structure
provided by XML.  It also describes the methods XML provides for
the expression of rules defining how units of textual structure can
   meaningfully be combined in a text.</p>

<div id="SG131"><head>Elements</head> <p>The technical term used in
XML for a textual unit, viewed as a structural component,
is <term>element</term>.  Different types of elements are given
different names, but XML provides no way of expressing the meaning of
a particular type of element, other than its relationship to other
element types.  That is, all one can say about an element called (for
instance) <gi>blort</gi> is that instances of it may (or may not)
occur within elements of type <gi>farble</gi>, and that it may (or may
not) be decomposed into elements of type <gi>blortette</gi>.  It
should be stressed that XML is entirely unconcerned with
the semantics of textual elements: these are application dependent. It
is up to the creators of XML vocabularies (such as these Guidelines)
to choose intelligible names for the elements they identify and to
define their proper use in text markup.  That is the chief purpose
of documents such as the TEI Guidelines.  From the need to choose element names indicative of
function comes the technical term for the name of an element type,
which is <term>generic identifier</term>, or GI.</p>

<p>Within a marked up text (a <term>document instance</term>), each
element must be explicitly marked or tagged in some way.  This is done
by inserting a tag at the beginning of the element (a
<term>start-tag</term>) and another at its end (an
<term>end-tag</term>).<note place="foot">In SGML (but not in XML) the
name and the content model may be separated by an additional part of
the declaration which specifies <soCalled>omission rules</soCalled>
for the element concerned. These rules state whether or not start- and
end-tags must be present for every occurrence of the element
concerned: as noted above, such tag omission is not permitted in XML,
and is not permitted in the TEI Interchange format.</note> The
start- and end-tag pair are used to bracket off the element
occurrences within the running text, in rather the same way as
different types of parentheses or quotation marks are used in
conventional punctuation. For example, a quotation element in a text
might be tagged as follows:
 
<q rend="eg">... Rosalind's remarks &lt;quote&gt;This is the silliest stuff
that ere I heard of!&lt;/quote&gt; clearly indicate ...</q>
 
As this example shows, a start-tag takes the form <code>&lt;quote&gt;</code>,
where the opening angle bracket indicates the start of the start-tag,
<q>quote</q> is the generic identifier of the element which is being
delimited, and the closing angle bracket indicates the end of a tag.
An end-tag takes an identical form, except that the opening angle
bracket is followed by a solidus (slash) character, so that the
corresponding end-tag is <code>&lt;/quote&gt;</code>.<note place="foot">Because
the opening angle bracket has this special function in an XML
document, special steps must be taken to use that character for other
purposes (for example, as the mathematical less-than operator); see
further <ptr target="SG-er"/>; in SGML (but not XML) different
characters may be defined for use as any of the delimiting characters
(the angle brackets, exclamation mark and
solidus).</note></p></div>

<div id="SG132"><head>Content models:  an example</head>

<p>An element may be <term>empty</term>, that is, it may have no
content at all, or it may contain just a sequence of characters with
no other elements.  More usually, however,
elements of one type will be <term>embedded</term> (contained entirely)
within elements of a different type.
</p>

<p>To illustrate this, we will consider a very simple structural
model. Let us assume that we wish to identify within an anthology
only poems, their titles, and the stanzas and lines of which they are
composed. In XML terms, our <term>document type</term> is the
<term>anthology</term>, and it consists of a series of
<term>poem</term>s. Each poem has embedded within it one element, a
<term>title</term>, and several occurrences of another, a
<term>stanza</term>, each stanza having embedded within it a number of
<term>line</term> elements. Fully marked up, a text conforming to
this model might appear as follows:<note place="foot">The example is
taken from William Blake's <title>Songs of innocence and
experience</title> (1794). The markup is designed for illustrative
purposes and is not TEI-conformant.</note>
 
<q rend="eg">&lt;anthology&gt;
  &lt;poem&gt;&lt;title&gt;The SICK ROSE&lt;/title&gt;
    &lt;stanza&gt;
      &lt;line&gt;O Rose thou art sick.&lt;/line&gt;
      &lt;line&gt;The invisible worm,&lt;/line&gt;
      &lt;line&gt;That flies in the night&lt;/line&gt;
      &lt;line&gt;In the howling storm:&lt;/line&gt;
    &lt;/stanza&gt;
    &lt;stanza&gt;
      &lt;line&gt;Has found out thy bed&lt;/line&gt;
      &lt;line&gt;Of crimson joy:&lt;/line&gt;
      &lt;line&gt;And his dark secret love&lt;/line&gt;
      &lt;line&gt;Does thy life destroy.&lt;/line&gt;
    &lt;/stanza&gt;
  &lt;/poem&gt;
            &lt;!-- more poems go here    --&gt;
&lt;/anthology&gt;</q></p>
<p>It should be stressed that this example does <emph>not</emph> use
the same names as are proposed for corresponding elements elsewhere
in these Guidelines: the above is <emph>not</emph> a valid TEI document.
It will however serve as an introduction to the basic notions of XML.
Whitespace and line breaks have been added to the example for the
sake of visual clarity only; they have no particular significance in the
XML encoding itself.  Also, the line
 
<q rend="eg">              &lt;!-- more poems go here    --&gt; </q>
 
is an XML <term>comment</term> and is not treated as part of the text.</p>
<p>As it stands, the above example is what is known as a
<term>well-formed</term> XML document: to achieve this status, an XML
document must obey the following simple rules:
<list>
<item>there should be a single element (start- and end- tag pair)
which encloses the whole document: this is known as the <term>root
element</term> (<gi>anthology</gi> in our case);</item>
<item>each element should be completely contained by the root element,
or by an element which is so contained; elements may not partially
overlap one another;</item>
<item>the tags marking the start and end of each element must always
be present. <note place="foot">This is not strictly true for empty
elements, for which start- and end-tags can be combined, as further discussed below.</note></item>
</list>
   </p>

<p>An XML document which is well-formed can be processed in a number
    of useful ways.  A simple indexing program could extract only the
    relevant text elements in order to make a list of titles, first
    lines, or words used in the poem text; a simple formatting program
    could insert blank lines between stanzas, perhaps indenting the
    first line of each, or inserting a stanza number.  Different parts
    of each poem could be typeset in different ways.  A more ambitious
    analytic program could  relate the use of punctuation marks to stanzaic
    and metrical divisions.<note place="foot">Note that this simple
    example has not addressed the problem of marking elements such as
    sentences explicitly; the implications of this are discussed below
    in section <ptr target="SG152"/>.</note> Scholars wishing to see
    the implications of changing the stanza or line divisions chosen
    by the editor of this poem can do so simply by altering the
    position of the tags.  And of course, the text as presented above
    can be transported from one computer to another and processed by
    any program (or person) capable of making sense of the tags
    embedded within it with no need for the sort of transformations
    and translations needed to move word processor files around.</p>

<p>However, well-formedness alone is not enough for the full range of
    what might be useful in marking up a document. It might well be
    useful if, in the process of preparing our digital anthology, a
    computer system could check some basic rules about how stanzas,
    lines, and titles can sensibly co-occur in a document. It would be
    even more useful if the system could check that stanzas are always
    labelled <code>&lt;stanza&gt;</code> and not occasionally <code>&lt;canto&gt;</code>
    or <code>&lt;Stanza&gt;</code>.  An XML document in which such rules have
    been checked is technically known as a <term>valid</term>
    document, and the ability to perform such validation is one of the
    key advantages of using XML. To carry this out, some way of
    formally stating the criteria for successful validation is necessary: in XML
    this formal statement may be provided by an additional document known
    as a <term>document type declaration</term> (DTD) or by an
    <term>XML schema</term>.<note place="foot">The DTD language described in the remainder of this
    section is neither the only way of representing such
    criteria, nor the most powerful. One important alternative is
    provided by another W3C Recommendation: the XML Schema language
		  (<xptr doc="XMLSchema"/>); another is
		  provided by the OASIS Committee's specification for Relax NG (<xptr doc="RelaxNG"/>).
It is highly probable that future releases of these Guidelines will
use such a language, in preference to, or as well as, a DTD.
</note></p>
</div></div>

<div id="SG14"><head>Validating a document's structure</head>

<p>Rules such as those informally stated above are the first stage in
the creation of a formal specification for the structure of an XML
document, or <term>document type declaration</term>, usually
abbreviated to <term>DTD</term>.  In creating a DTD, the document
designer may be as lax or as restrictive as the occasion warrants.  A
balance must be struck between the convenience of following simple
rules and the complexity of handling real texts. This is particularly
the case when the rules being defined relate to texts which already
exist: the designer may have only the haziest of notions as to an
ancient text's original purpose or meaning and hence find it very
difficult to specify consistent rules about its structure.  On the
other hand, where a new text is being prepared to an exact
specification, for example for entry into a textual database of some
kind, the more precisely stated the rules, the better they can be
enforced.  Even in the case where an existing text is being marked up,
it may be beneficial to define a restrictive set of rules relating to
one particular view or hypothesis about the text &#x2013; if only as a
means of testing the usefulness of that view or hypothesis.  It is
important to remember that every document type declaration results
from an interpretation of a text.  There is no single DTD which
encompasses any kind of absolute truth about a text, although it may
be convenient to privilege some DTDs above others for particular types
of analysis.</p>

<p>XML is widely used in environments where uniformity
of document structure is a major desideratum.  In the production of
technical documentation, for example, it is of major importance that
sections and subsections should be properly nested, that cross
references should be properly resolved and so forth.  In such
situations, documents are seen as raw material to match against
pre-defined sets of rules.  As discussed above, however, the use of
simple rules can also greatly simplify the task of tagging accurately
elements of less rigidly constrained texts.  By making these rules
explicit, the scholar reduces his or her own burdens in marking up and
verifying the electronic text, while also being forced to make explicit
an interpretation of the structure and significant particularities of
the text being encoded.</p>

<div id="SG141"><head>An example DTD</head>

<p>A DTD is expressed as a set of declarative statements, using a
special purpose syntax which we introduce informally below.  For our
simple model of a poem, the following declarations would be
appropriate:
 
<q rend="eg">&lt;!ELEMENT anthology     (poem+)&gt;
&lt;!ELEMENT poem          (title?, stanza+)&gt;
&lt;!ELEMENT title         (#PCDATA) &gt;
&lt;!ELEMENT stanza        (line+)   &gt;
&lt;!ELEMENT line          (#PCDATA) &gt;</q>
 
These five lines are examples of formal XML element declarations.  A
declaration, like an element, is delimited by angle brackets; the
first character following the opening bracket must be an exclamation
mark, followed immediately by one of a small set of XML-defined
keywords, specifying the kind of object being declared.  The five
declarations above are all of the same type: each begins with an
<code>ELEMENT</code> keyword, indicating that it declares an element,
in the technical sense defined above.  Each consists of two parts: a
name, or <term>generic identifier</term> and a <term>content
model</term>.<note place="foot">In SGML (but not in XML) the name and
the content model are separated by an additional part of the
declaration which specifies <term>minimization rules</term> for the
element concerned. Minimization (informally speaking, whether or not
start- and end-tags must be present in every occurrence of the element
concerned) is not permitted in XML, and is not recommended in the TEI
Interchange format.</note>   Each of
these parts is discussed further below.  Components of the declaration
are separated by <term>whitespace</term> characters, that is one or more blanks, tabs or
newlines.</p>

  </div>
<div id="SG141x"><head>Generic identifier</head>

<p>The first part of each declaration above gives the generic
identifier (often abbreviated to GI) of the element which is being
declared, for example <mentioned>poem</mentioned>,
<mentioned>title</mentioned>, etc.  A GI may contain alphabetic
characters, digits, hyphens, underscore characters, or fullstops, and
must begin with a letter. In general, uppercase and lowercase letters
are regarded as distinct characters: an element with the GI
<gi>foo</gi> is <emph>not</emph> the same as an element with the GI
<gi>Foo</gi>: the root element of a TEI-conformant document is thus
<gi>TEI.2</gi>, <emph>not</emph> <gi>tei.2</gi>.<note place="foot">In
XML, a single colon may also appear in a GI, where it has a special
significance related to the use of <term>namespaces</term>, as further
discussed in section <ptr target="SGname"/>. The characters defined by
Unicode as <term>combining characters</term> and as
<term>extenders</term> are also permitted. In SGML, the rules stated
informally here may vary somewhat depending on the SGML declaration in
force; in particular, it is not usually the case that upper and lower
case letters are distinguished, although such usage is highly
recommended for TEI Interchange. The present version of the Guidelines
does not mandate this, for compatibility reasons, but this is likely
to change in a subsequent release.</note></p></div>

<div id="SG143"><head>Content model</head>

<p>The second part of each declaration, enclosed in parentheses, is
called the <term>content model</term> of the element being defined, because it
specifies what may legitimately be contained within it.  Contents
are specified either in terms of other elements or using special
reserved words.  There are several such reserved words, of which by
far the most commonly encountered is <code>#PCDATA</code>, as in this example.
This is an abbreviation for <gloss>parsed character data,</gloss> and
it means that the element being defined may contain any valid
character data (but no elements).  If an XML declaration is thought of as a structure
like a family tree, with a single ancestor at the top (in our case,
this would be <code>&lt;anthology&gt;</code>), then almost always, following the
branches of the tree downwards (for example, from <gi>anthology</gi>
to <gi>poem</gi> to <gi>stanza</gi> to <gi>line</gi> and
<gi>title</gi>) will lead eventually to <code>#PCDATA</code>. In our example,
<gi>title</gi> and <gi>line</gi> are so defined, since their content
models say <code>#PCDATA</code> only and name no embedded elements.</p></div>

<div id="SG144"><head>Occurrence indicators</head>

<p>The declaration for <gi>stanza</gi> in the example above states
that a stanza consists of one or more lines.  It uses an
<term>occurrence indicator</term> (the plus sign) to indicate how many
times the element named in its content model may occur.  There are
three occurrence indicators: the plus sign, the question mark, and the
asterisk or star.  The plus sign means that there may be one or more
occurrences of the element concerned; the question mark means that
there may be at most one and possibly no occurrence; the star means
that the element concerned may either be absent or appear one or more
times.  Thus, if the content model for <gi>stanza</gi> were
<code>(line*)</code>, stanzas with no lines would be possible as well
as those with more than one line.  If it were <code>(line?)</code>,
again empty stanzas would be countenanced, but no stanza could have
more than a single line.  The declaration for <gi>poem</gi> in the
example above thus states that a <gi>poem</gi> cannot have more than
one title, but may have none, and that it must have at least one
<gi>stanza</gi> and may have several.
 
</p></div>
<div id="SG145"><head>Connectors</head>
<p>The content model <code>(title?, stanza+)</code> contains
more than one component, and thus needs additionally to specify the
order in which these elements (<gi>title</gi> and <gi>stanza</gi>) may
appear.  This ordering is determined by the <term>connector</term> (the comma) used between its components.
There are two possible connectors: the comma, representing
sequence, and the vertical bar, representing alternation.<note place="foot">In SGML (but not XML), a third connector, the ampersand,
is sometimes used, signifying that the components connected by it may
appear in either order. Its use is not supported (or recommended) by
the TEI interchange format of SGML.</note>
If the comma in this example were replaced by a vertical bar, then a <gi>poem</gi> would consist of
either a title or just stanzas &#x2013; but not both!</p></div>

<div id="SG146"><head>Model groups</head>

<p>In our example so far, the components of each content model have
been either single elements or <code>#PCDATA</code>.  It is quite permissible
however to define content models in which the components are lists of
elements, combined by connectors.  Such lists, known as <term>model
groups</term>, may also be modified by occurrence indicators and
themselves combined by connectors.  To demonstrate these facilities,
let us now expand our example to include non-stanzaic types of verse.
For the sake of demonstration, we will categorize poems as one of
<term>stanzaic</term>, <term>couplets</term>, or <term>blank</term>
(or <term>stichic</term>).  A blank-verse poem consists simply of
lines (we ignore the possibility of verse paragraphs for the
moment)<note place="foot">It will not have escaped the astute reader
that the fact that verse paragraphs need not start on a line boundary
seriously complicates the issue; see further section <ptr target="SG152"/>.</note> so no additional elements need be defined for
it.  A couplet is defined as a <gi>firstLine</gi> followed by a
<gi>secondLine</gi>.
 
<q rend="eg">&lt;!ELEMENT couplet (firstLine, secondLine) &gt;</q>
 


</p>

<p>The elements <gi>firstLine</gi> and <gi>secondLine</gi> (which are
distinguished to enable studies of rhyme scheme, for example) have
exactly the same content model as the existing <gi>line</gi>
element;<note place="foot">In SGML, but not XML, it is possible to use
a group of names instead of a single GI within an element declaration,
so the three declarations could be combined like this:
<q rend="eg">&lt;!ELEMENT (line|firstLine|secondLine) O O (#PCDATA)&gt;</q>This 
is not however supported by the TEI
Interchange Format.</note> we will therefore add the following two
lines to our example DTD:

<q rend="eg">&lt;!ELEMENT firstLine  (#PCDATA)&gt;
&lt;!ELEMENT secondLine (#PCDATA)&gt;</q>
Next, we can change the declaration for the <gi>poem</gi> element 
to include all three possibilities:
 
<q rend="eg">&lt;!ELEMENT poem  (title?, (stanza+ | couplet+ | line+) ) &gt;</q>
 
That is, a poem consists of an optional title, followed by one or
several stanzas, or one or several couplets, or one or several lines.
Note the difference between this declaration and the following:
 
<q rend="eg">&lt;!ELEMENT poem  (title?, (stanza | couplet | line)+ ) &gt;</q>
 
The second version, by applying the occurrence indicator to the group
rather than to each element within it, would allow for a single poem to
contain a mixture of stanzas, couplets, or lines.</p>

<p>A model group can contain <code>#PCDATA</code> as well as named elements: this
combination, known as <term>mixed content</term>, allows for elements
in which the sub-components appear with intervening stretches of
character data. For example, if we wished to mark place names wherever
they appear inside our verse lines, then, assuming we have also added a suitable declaration for the
<gi>name</gi> element, we could change the
definition for <gi>line</gi> to
<q rend="eg">&lt;!ELEMENT line  (#PCDATA | name )* &gt;</q>
</p>
<p>XML (but not SGML) places several constraints on the way that mixed
content models may be defined. In brief, if <code>#PCDATA</code> appears with other
elements in a
content model: it must always appear as the first option in an
alternation; it may appear once only, and in the outermost model
group; and if the group containing it is repeated, the star operator
must be used.<note place="foot">The (good) rationale for these restrictions
is beyond the scope of this tutorial, as are the consequences of
attempting to evade them. The TEI content models all obey these constraints.</note></p>

<p>Quite complex models can easily be built up in this way, to match
the structural complexity of many types of text.  As a further example,
consider the case of stanzaic verse in which a refrain or chorus
appears.  Like a stanza, a refrain consists of repetitions of the line element.
A refrain can
appear at the start of a poem only, or as an optional addition
following each stanza.  This could be expressed by a content model such
as the following:
<q rend="eg">&lt;!ELEMENT refrain (line+)&gt;
&lt;!ELEMENT poem   (title?, ( line+ | (refrain?, (stanza, refrain?)+ ))) &gt;</q>
That is, a poem consists of an optional title, followed by either
a sequence of lines, or an un-named group, which starts with an
optional refrain, followed by one of more occurrences of another group,
each member of which is composed of a stanza followed by an optional
refrain.  A sequence such as <mentioned>refrain - stanza - stanza - refrain</mentioned>
follows this pattern, as does the sequence <mentioned>stanza - refrain -
stanza
- refrain</mentioned>.  The sequence <mentioned>refrain - refrain - stanza -
stanza</mentioned>
does not, however, and neither does the sequence <q>stanza - refrain -
refrain - stanza.</q>  Among other conditions made explicit by this
content model are the requirements that at least one stanza must appear
in a poem, if it is not composed simply of lines, and that if there is
both a title and a stanza they must appear in that order.</p>
<p>Note that the apparent complexity of this model derives from the
constraints expressed informally above. A simpler model, such as <q rend="eg">&lt;!ELEMENT poem   (title?, (line|refrain|stanza)+ ) &gt;</q> would not enforce any of them, and would therefore permit
such anomalies as a poem consisting only of refrains, or an arbitrary mixture of
lines and refrains. </p>
</div></div>

<div id="SG152"><head>Complicating the issue</head>

<p>In the simple cases described so far, it has been assumed that one
can identify the immediate constituents of every element  in a
textual structure.  A poem consists of stanzas, and an anthology
consists of poems.  Stanzas do not float around unattached to poems or
combined into some other unrelated element; a poem cannot contain an
anthology.  All the elements of a given document type may be arranged
into a hierarchic structure, arranged like a family tree with a single
ancestor at one end and many children (mostly the elements containing
<code>#PCDATA</code>) at the other. For example, we could represent an anthology
containing two poems, the first of which contains two four-line
stanzas and the second a single stanza,  by a tree structure like the following figure:


<figure width="5in" entity="XMLfig"/>


</p>

<p>Clearly, there are many such trees that might be drawn to describe
the structure of this or other anthologies.  Some of them might be
representable as further subdivisions of this tree: for example, we
might subdivide the lines into individual words, since no word crosses
a line boundary. Surprisingly perhaps, this grossly simplified view
of what text is (memorably termed an <term>ordered hierarchy of
content objects</term> (OHCO) view of text by Renear <foreign>et
al</foreign>)<note place="foot">See <bibl>Renear, A., Mylonas, E.,
Durand, D. <title level="a">Refining our notion of what text really
is: the problem of overlapping hierarchies</title> in Ide and Hockey,
eds., <title>Research in Humanities Computing</title>, OUP,
1996</bibl></note> turns out to be very effective for a large number
of purposes. It is not however adequate for the full complexity of
real textual structures, for which more complex mechanisms need to be
employed.  For there are many other trees that might be drawn which do
<emph>not</emph> fit within this tree.  We might, for example, be
interested in syntactic structures &#x2014; which rarely respect the
formal boundaries of verse.  Or, to take a simpler example, we might
want to represent the pagination of different editions of the same
text.</p>

<p>In the OHCO model of text, representation of cases where
different elements overlap so that several different trees may be
identified in the same document, is generally problematic. A single
hierarchy must be chosen, and the points at which other hierarchies
intersect with it marked (so we might, for example, mark the
pagination by means of empty elements marking the boundary between one
page and the next). Or we could represent alternative  hierarchies
by means of the pointing and linking
mechanisms described in chapter 14 of the TEI Guidelines. These mechanisms
all depend on the use of <term>attributes</term> which may be used both to
identify particular elements within a document, and to point to, link,
or align them into arbitrary structures.<note place="foot">SGML
(but not XML) provides a mechanism to 
define <soCalled>concurrent</soCalled> document
structures, which is discussed in chapter 31 of the TEI Guidelines below;
however, this is not widely implemented, and is not further discussed
here.</note></p></div>

<div id="SG16"><head>Attributes</head>

<p>In the XML context, the word <mentioned>attribute</mentioned>, like
some other words, has a specific technical sense.  It is used to
describe information which is in some sense descriptive of a specific
element occurrence but not regarded as part of its content. For
example, you might wish to add a <ident>status</ident> attribute to
occurrences of some elements in a document to indicate their degree of
reliability, or to add an <ident>identifier</ident> attribute so that you
could refer to particular element occurrences from elsewhere within a
document.  Attributes are useful in precisely such circumstances.</p>
<p>Although different elements may have attributes with the same name,
(for example, in the TEI scheme, every element is defined as having an
attribute named <ident>lang</ident>), they are always regarded as
different, and may have different values assigned to them.  If an
element has been defined as having attributes, the attribute values
are supplied in the document instance as <term>attribute-value
pairs</term> inside the start-tag for the element occurrence. An
end-tag may not contain an attribute-value specification, since it
would be redundant.</p>

<p>The order in which attribute-value pairs are supplied inside a tag
   has no significance; they must however be separated by at least one
   whitespace (blank, newline, or tab) character. In XML, the value
   part must always be given inside matching quotation marks, either
   single or double.<note place="foot">In SGML, the quotation marks may
    be omitted in certain circumstances; however their use is required
    by the TEI interchange format.</note></p>

<p>For example:
	  <q rend="eg">&lt;poem id='P1' status=&quot;draft&quot;&gt; ... &lt;/poem&gt;</q>
Here attribute values are being specified for two attributes
    previously declared
    for the <gi>poem</gi> element: <ident>id</ident> and
    <ident>status.</ident> For the instance of a <gi>poem</gi> in this
    example, represented here by an ellipsis, the <ident>id</ident>
    attribute has the value <code>P1</code> and the <ident>status</ident>
    attribute has the value <code>draft</code>. An XML processor can
    use the values of the attributes in any way it chooses; for
    example, a formatter might print a poem element which has the
    status attribute set to <code>draft</code> in a different way from
    one with the same attribute set to <code>revised</code>; another
    processor might use the same attribute to determine whether or not
    poem elements are to be processed at all.  The <ident>id</ident>
    attribute is a slightly special case in that, by convention, it is
    always used to supply a unique value to identify a particular
    element occurrence, which may be used for cross reference
    purposes, as discussed further below.</p>

<div><head>Declaring attributes</head>

<p>Like elements, attributes are declared in the XML DTD, using rather
similar syntax.  As well as specifying its name and the element to
which it is to be attached, it is possible to specify (within limits)
what kind of value is acceptable for an attribute and a default
value.</p>

<p>The following declarations could be used to define the two attributes
we have supplied above for the <gi>poem</gi> element:
 
<q rend="eg">&lt;!ATTLIST poem
          id       ID                              #IMPLIED
          status   (draft | revised | published)   &quot;draft&quot;        &gt;</q></p>

<p>The declaration begins with the symbol <code>ATTLIST</code>, which
introduces an <term>attribute list specification</term>. This first
specifies the element concerned, <code>poem</code> in this
example.<note place="foot">As with content models, it is possible in
SGML (but not in XML) to combine several attribute specifications
together in a single declaration by supplying a list of element names
instead of a single name; this is not however done in the current
version of the TEI DTDs.</note> Following this name is a series of
rows, one for each attribute being declared, each containing three
parts.<note place="foot">These parts are conventionally lined up in
rows for human readability; the parser only requires that there be
some kind of whitespace between them.</note> These specify the name
of the attribute, the type of value it takes, and a default value
respectively.</p></div>

<div><head>Attribute names</head>
<p>Attribute names (<ident>id</ident> and <ident>status</ident> in
this example) are subject to the same restrictions as other names in
XML; they need not be unique across the whole DTD, however, but only
within the list of attributes for a given element.</p>
   </div>
<div><head>Attribute values</head>
<p>The second part of an attribute specification can take one of two
forms, both illustrated above.  The first case uses one of a number of
special keywords to declare what kind of value an attribute may take.
In the example above, the special keyword <code>ID</code> is
used to indicate that the attribute <ident>id</ident> will be used to
supply a unique identifying value for each poem instance (see further
the discussion in <ptr target="SG-id"/> below).  Possible keywords include:
<list>
<item><code>CDATA</code>: the attribute value may contain any valid character data,
including spaces or punctuation marks; even tags may be included in
the value, but they will not be recognized by the XML parser, and will
not be processed as tags normally are; </item>
<item><code>NMTOKEN</code>: the attribute value must contain only
          those characters that are valid within a name or a generic
          identifier. </item>
<item><code>NMTOKENS</code>: the attribute value must contain one or
more <code>NMTOKEN</code> values separated by one or more whitespace characters.</item>
<item><code>ID</code>: the attribute value must be a single word starting with an
          alphabetic character, which can be used as a unique
          identifier (i.e. a given value can only be used once as the
          value for any <code>ID</code> attribute);</item>
<item><code>IDREF</code>: The attribute value must contain a single
          word, which has been used as a unique identifier on  some
other element; </item>
<item><code>IDREFS</code>: The attribute value must contain one or
more <code>IDREF</code> values, separated by one or more whitespace characters;
</item>
<item><code>ENTITY</code>: The attribute value must contain a <code>NMTOKEN</code>
value which has previously been declared to be the name of some XML
<term>entity</term> (<ptr target="SG17"/>).</item>
<item><code>ENTITIES</code>: The attribute value must contain one or
more <code>ENTITY</code> values, separated by one or more whitespace characters.</item>
</list>
  </p>

<p>In the example above, a list of the possible values for the
<ident>status</ident> attribute has been supplied.  This means that a
parser can check that no <gi>poem</gi> is defined for which the
<ident>status</ident> attribute does not have one of <code>draft</code>,
<code>revised</code>, or <code>published</code> as its value.
Alternatively, a parser would have accepted almost any unbroken string
of characters (<code>status=&quot;awful&quot;</code>,
<code>status=&quot;awe-ful&quot;</code>, or <code>status=&quot;12345678&quot;</code>) if
it had been a <code>NMTOKEN</code>; or almost any string at all
(<code>status=&quot;anything goes&quot;</code> or <code>status = &quot;well, ALMOST
anything&quot;</code>) if it were <code>CDATA</code>.  Sometimes, of
course, the set of possible values cannot be pre-defined.  Where it
can, as in this case, it is generally better to do so.  </p> </div>

<div><head>Default value</head> <p>The last piece of information in
each attribute declaration specifies how a parser should interpret the
absence of the attribute concerned.  This can be done by supplying one
of the special keywords listed below, or (as in this case) by
supplying a specific value which is then regarded as the value for
every element which does not supply a value for the attribute
concerned.  Using the example above, if a poem is simply tagged
<code>&lt;poem&gt;</code>, the parser will treat it exactly as if it were tagged
<code>&lt;poem status=&quot;draft&quot;&gt;</code>.  Alternatively, one of the following
keywords may be used to specify a default value for an attribute:
 
<list>
<item><code>#REQUIRED</code>: a value must be specified;</item>
<item><code>#IMPLIED</code>:  value need not be supplied.</item>
</list></p>
<p>Thus, if the attribute declaration above were rewritten as
 
<q rend="eg">
&lt;!ATTLIST poem   id ID #IMPLIED 
                 status (draft | revised | published) #REQUIRED &gt;</q>

then poems which appear in the anthology simply tagged <code>&lt;poem&gt;</code>
would be reported as erroneously tagged, as would any for which some
value other than <code>draft,</code> <code>published,</code> or
<code>revised</code> were supplied.</p>

   </div>
<div id="SG-id"><head><code>ID</code> and <code>IDREF</code> attributes</head>
<p>It is sometimes necessary to refer to an occurrence of one textual
element from within another, an obvious example being phrases such as
<q>see note 6</q> or <q>as discussed in chapter 5.</q>  When a text is
being produced the actual numbers associated with the notes or chapters
may not be certain.  If we are using descriptive markup, such
things as page or chapter numbers, being entirely matters of
presentation, will not in any case be present in the marked up text:
they will be assigned by whatever processor is operating on the text
(and may indeed differ in different applications).  XML therefore
provides a special mechanism by which any element occurrence may be
given a special identifier, a kind of label, which may be used to refer
to it from anywhere  else within the same text.  The cross-reference
itself is regarded as an element occurrence of a specific kind, which
must also be declared in the DTD.  In each case, the identifying label
(which may be arbitrary) is supplied as the value of a special
attribute.</p>
<p>Suppose, for example, we wish to include a reference within
the notes on one poem that refers to another poem.  We will
first need to provide some way of attaching a label to each
poem:  this is done by defining an attribute for the
<gi>poem</gi> element, as suggested above.
 
<q rend="eg">&lt;!ATTLIST poem
          id       ID     #IMPLIED &gt;</q></p>
<p>Here we define an attribute <ident>id</ident>, the value of which must be
of type <code>ID</code>.  It is not required that any attribute
of type <code>ID</code> have the name <ident>id</ident> as
well; it is however a useful convention almost universally observed.
Note that not every poem need carry an <ident>id</ident> attribute and the
parser may safely ignore the lack of one in those which do not.  Only
poems to which we intend to refer need use this attribute; for each such
poem we should now include in its start-tag some unique identifier, for
example:
 
<q rend="eg">&lt;poem id='ROSE'&gt;
     &lt;!-- Text of poem with identifier 'ROSE' --&gt;
&lt;/poem&gt;
&lt;poem id='P40'&gt;
     &lt;!-- Text of poem with identifier 'P40' --&gt;
&lt;/poem&gt;
&lt;poem&gt;
     &lt;!-- This poem has no identifier --&gt;
&lt;/poem&gt;
 </q></p>
<p>Next we need to define a new element for the cross reference
itself.  This will not have any content &#x2013; it is only a
pointer &#x2013; but it has an attribute, the value of which will be
the identifier of the element pointed at.  This is achieved by
the following declarations:
 
<q rend="eg">&lt;!ELEMENT poemRef   EMPTY                  &gt;
&lt;!ATTLIST poemRef   target IDREF #REQUIRED &gt;</q></p>
<p>The <gi>poemRef</gi> element has the special content model
    <code>EMPTY</code> because it has
no content.  It has a single attribute called <ident>target</ident>.  The
value of this attribute must be of type <code>IDREF</code> (the keyword used for
cross reference pointers of this type); furthermore, because the
default value is <code>#REQUIRED</code>, it must be supplied on each
occurrence &#x2014; a <gi>poemRef</gi> with no referent is an impossibility.</p>

<p>With these declarations in force, we can now encode a reference to
the poem whose <ident>id</ident> attribute specifies that its identifier
is <code>Rose</code> as follows:
 
<q rend="eg">Blake's poem on the sick rose 
&lt;poemRef target='Rose'/&gt; ...</q>

In this example, we have used the special syntax defined by XML for
representing empty elements in
which the end-tag and the start-tag are combined into a single tag.<note place="foot">XML also permits representation of empty elements by an
immediately adjacent start- and end-tag, thus 
<q rend="eg">&lt;poemRef target='Rose'&gt;&lt;/poemRef&gt;</q>
Neither form is by default permitted for
elements declared as <code>EMPTY</code> in an SGML context, for which empty
elements should be represented by a start-tag in isolation, unless the
SGML declaration has been modified to permit the first XML style cited
above. Conversion of the way empty elements are represented is thus
usually necessary when processing SGML legacy data in an XML environment.</note></p>

<p>When an XML parser encounters this empty element it will simply
check that an element exists with the identifier <code>Rose</code>.
Different XML processors could take any number of additional actions:
a formatter might construct an exact page and line reference for the
location of the poem in the current document and insert it, or just
quote the poem's title or first lines.  A hypertext style processor
might use this element as a signal to activate a link to the poem
being referred to.  The purpose of the XML markup is simply to
indicate that a cross reference exists: it does not determine what the
processor is to do with it.</p></div></div>

<div id="SG17"><head>Entities</head>

<p>The aspects of XML discussed so far are all concerned with the
markup of structural elements within a document.  XML also provides a
simple and flexible method of encoding and naming arbitrary parts of
the actual content of a document in a portable way.  In XML the word
<term>entity</term> has a special sense:  it means a named part of a
marked up document, irrespective of any structural considerations.  An
entity might be a string of characters or a whole file of text.
   Entities are declared in a DTD in the same way as elements or
   attributes, and they are included  in a document using a construction known as an
<term>entity reference</term>.  
  </p>
<div id="SG-ents"><head>Entity declarations</head>

<p>Like all other declarations, an  entity declaration begins with a
     special keyword, in this case the word
     <ident>ENTITY</ident>, followed by the name of the entity
     to be declared, and the value to be used when it is referenced in
     the document. For example, the following declaration
 
<q rend="eg">&lt;!ENTITY tei &quot;Text Encoding Initiative&quot;&gt;</q>
 
defines an entity whose name is <ident rend="noindex">tei</ident> and
whose value is the string <code>Text Encoding Initiative</code>. This is an
instance of an <term>entity declaration</term>, which declares an
<term>internal entity</term>.  The following declaration, by contrast,
declares an <term>external entity</term> (sometimes called, loosely, a
<term>system entity</term>):
 
<q rend="eg">&lt;!ENTITY ChapTwo SYSTEM &quot;p4chap2.xml&quot;&gt;</q>
 
This defines an external entity whose name is <ident rend="noindex" type="ge">ChapTwo</ident> and whose value is the text associated with
the system identifier &#x2014; in this case, the system identifier is
the name of an operating system file and the replacement text of the
entity is the contents of the file. However, XML does not require
system identifiers to be operating-system file names.<note place="foot">In general, an external entity can be any data source
available to the XML processor: files, results of database queries,
results of calls to system functions, web pages &#x2014; anything at
all. System identifiers can use any method to name an entity which the
XML parser's interface to its operating environment can use to elicit
data from the environment.</note> We might define the same entity as
referring to a web page: <q rend="eg">&lt;!ENTITY ChapTwo SYSTEM
&quot;http://www.tei-c.org/P4X/p4chap2.xml&quot;&gt;</q>
</p>

<p>System identifiers are, by their nature, system dependent; in the
interests of data portability, therefore, XML provides another way of
declaring external entities, shown here: 
<q rend="eg">&lt;!ENTITY p3.sg
PUBLIC &quot;-//TEI//TEXT Guidelines Chapter on XML//EN&quot;
&quot;p4chap2.xml&quot;&gt;</q> Here, the keyword <code>SYSTEM</code> has been
replaced by the keyword <code>PUBLIC</code>, and the system identifier
has been preceded by a special string known as a <term>formal public identifier</term>.
Although public identifiers can (in principle) take virtually any
form; it is usual to use the form shown above, in which the delimiters
<mentioned>//</mentioned> divide the identifier into the following
parts: <list type="gloss"><label>TEI</label> <item>indicates the
owner of this public identifier (often but not necessarily the owner
of the data in question); the preceding <mentioned>-</mentioned>
signals that this particular owner identifier is not registered with
ISO (a <mentioned>+</mentioned> would imply that one could find out
the full name and address of the owner from the official registry of
owner identifiers)</item> <label>TEXT</label> <item>is a keyword
indicating the nature of the entity: other legal values are
<code>DOCUMENT</code> (for full XML documents), <code>DTD</code> (for
document type declarations), <code>ELEMENTS</code> (for sets of
element declarations), <code>ENTITIES</code> (for sets of entity
declarations), <code>NOTATION</code> (for notation definitions), 
and a number of others which are less frequently needed
and will not be discussed here.</item> <label>Guidelines Chapter on
XML</label> <item>gives a descriptive name to the
entity.</item><label>EN</label> <item>is the ISO language code for the
human language in which the entity is written.</item></list>
  </p>
<p>Public identifiers help make XML documents less dependent
on particular computer systems, by making it possible to confine the
   mapping between entity names and system identifiers to a single
   place. As with other such techniques, they  require XML systems
to provide mechanisms
for mapping from the public identifiers to file identifiers or other
system identifiers: such a mapping is typically provided by an
additional component known as a <term>catalog file</term> (<ptr target="SGPATANC"/>).</p>
   </div>
<div id="SG-er"><head>Entity references</head>
<p>Once an entity has been declared it may be referenced anywhere
within a document. This is done by supplying its name prefixed with
the ampersand character and followed by the semicolon.<note place="foot">In SGML (but not XML) the semicolon
may be omitted if the entity reference is followed by whitespace; this
      is not recommended practice, and may be prohibited in future
      revisions of these Guidelines.</note></p>
<p>When an XML parser encounters such an <term>entity
reference,</term> it immediately substitutes the value declared for
the entity name. Thus, the passage <code>The work of the &amp;tei; has
only just begun</code> will be interpreted by an XML processor exactly
as if it read <code>The work of the Text Encoding Initiative has only
just begun</code>. In the case of an external entity, it is, of course,
the contents of the operating system file which are substituted, so
that the passage <code>The following text has been suppressed:
&amp;ChapTwo;</code> will be expanded to include the whole of whatever
the system finds in the file <ident rend="noindex" type="file">p4chap2.xml</ident>.</p>

<p>This obviously saves typing, and simplifies the task of maintaining
consistency in a set of documents.  If the printing of a complex
document is to be done at many sites, the document body itself might use
an entity reference, such as <code>&amp;site;</code>, wherever
the name of the site is required.  Different entity declarations could
then be used at different sites to supply the appropriate string to be
substituted for this name, with no need to change the text of the
document itself.</p>
<p>In XML documents, two special entities are predefined, with the names
<ident>amp</ident> and <ident>lt</ident>. These are available  without
     declaration, so that the ampersand character or less-than sign
can be represented  in a text without their being confused with the start of
     an entity reference or a tag respectively.</p>
   </div>

<div id="SG-cer"><head>Character references</head>

<p>As mentioned above, XML documents all use the same internal
     character encoding. Since not all computer systems currently
     support this encoding directly, a special form of entity
     reference is defined which can be used to represent individual
     characters from the Unicode  character set in a portable
     way by simply representing their numeric value, in decimal or
     hexadecimal notation. </p>
<p>For example, the character &#xE9; is represented within an XML
     document as the Unicode character with hexadecimal value
     <code>00E9</code>. If such a document is being prepared on (or
     exported to) a system using a different character set, say ISO
     646, in which this character is not available, it may instead be
     represented by the character entity reference
     <code>&amp;#x00E9;</code> (the x indicating that what follows
     is a hexadecimal value) or <code>&amp;#0233;</code>. Entity
     references of this type do not need to be predefined in XML,
     since the underlying character encoding for XML is always the same.
    </p>

<p>To aid legibility however, it is common practice instead to use a
     mnemonic name (such as <code>eacute</code>) for such character
     references, and to map these to the appropriate Unicode value by
     means of entity declarations of exactly the same type as those
     already discussed. Standard mnemonic names have been defined by
     ISO for the characters in most widely-used writing systems, and
     grouped together into widely-available <term>entity
     sets</term>. The standard <soCalled>ISO lat1</soCalled> entity
     set, for example, includes a declaration like the following for
     the character &#xE9;:

<q rend="eg">&lt;!ENTITY eacute	&quot;&amp;#x00E9;&quot;&gt; &lt;!-- LATIN SMALL LETTER E WITH ACUTE --&gt;</q>

so that, for an XML document which embeds this entity set in its DTD,
a non-Unicode enabled input system may also represent this character
by the entity reference <code>&amp;eacute;</code>.</p>

<p>This <term>string substitution</term> mechanism has many other
applications. Suppose, for example, that we wish to encode the use of ligatures
in early printed texts.  The ligatured form of
<mentioned>ct</mentioned> might be distinguished from the
non-ligatured form by encoding it as <code>&amp;ctlig;</code>
rather than <code>ct.</code> Other special typographic features such
as leafstops or rules could equally well be represented by mnemonic
entity references in the text.  When processing such texts, an entity
declaration would be added giving the desired representation for such
textual elements.  If, for example, ligatured letters are of no
interest, we would simply add a declaration such as
 
<q rend="eg">&lt;!ENTITY ctlig &quot;ct&quot; &gt;</q>
 
and the distinction present in the source document would be removed.
If, on the other hand, a formatting program capable of representing
ligatured characters is to be used, we might replace the entity
declaration to give whatever sequence of characters such a program
requires as the expansion.</p>

<p>More detailed discussion of this and related character encoding
     issues is provided in chapter 4 of the TEI Guidelines</p></div>

<div id="SG-ue"><head>Unparsed entities and Notations</head>

<p>An XML entity may contain non-textual information such as pictures,
video, or sound in digitized form. Such objects can be embedded in a
document by reference in exactly the same way as any other external
entity. When such entities are declared, however, it is essential to
indicate that they contain data which an XML parser or processor
cannot handle in the same way as the surrounding data &#x2014; it is no
use trying to process entities contain pictures or sound as if they
contain text! This is accomplished by including an additional keyword
in the declaration of such entities, as in the following example:

<q rend="eg">&lt;!ENTITY fig1 SYSTEM &quot;figure1.png&quot; NDATA png&gt;</q>
 </p>
<p>The keyword <kw>NDATA</kw> indicates that this external entity is
<term>unparsed</term>: it contains non-XML data which an XML parser
should ignore. It is followed by an additional name (<code>png</code>
in the example above) which identifies the <term>notation</term> used
for this data, that is, the set of conventions which a processor must
understand in order to process the data correctly. XML may itself be
thought of as a notation, which is implied for all external entities
not otherwise labelled. Notations should be declared in a DTD along with
everything else: for the DTD in which the above declaration appears, a
notation declaration like the following would also be appropriate:
<q rend="eg">&lt;!NOTATION png PUBLIC
    '-//TEI//NOTATION IETF RFC2083 Portable Network Graphics//EN'&gt;</q>
This gives a formal public identifier for the place where the notation
<code>png</code> is defined.</p>

<p>More detailed discussion of external unparsed entities and of
recommended graphics notations are given in section 22.3 of the TEI Guidelines.  </p></div>


<div id="SG-pe"><head>Parameter entities</head>

<p>A special form of entities, <term>parameter entities</term>, may be
used within XML markup declarations; these differ from the entities
discussed above (which technically are known as <term>general
entities</term>) in two ways:
<list type="bullets">
<item>Parameter entities are used <emph>only</emph> within XML markup
declarations; they may not appear  within the document
itself.</item>
<item>Parameter entity references are delimited by percent sign and semicolon,
rather than by ampersand and semicolon.</item></list>
</p> 

<p>Declarations for parameter entities take the same form as those for
general entities, but insert a percent sign between the keyword
<code>ENTITY</code> and the name of the entity itself.  Whitespace characters
(blanks, tabs, or line breaks) must occur on both sides of the percent
sign.  For example, an internal parameter entity named <ident type="pe">a.global</ident> might be declared with the  expansion
<code>id ID #REQUIRED  rend CDATA #IMPLIED</code> as follows:
<q rend="eg">&lt;!ENTITY % a.global 
         'id ID #REQUIRED  rend CDATA #IMPLIED'&gt;</q>
</p>
<p>With this declaration at the start of a DTD, the task (for example) of declaring
attributes consistently on all elements within a DTD becomes much
simpler: all that is needed is to reference the parameter entity, as
in this example:
<q rend="eg">&lt;!ATTLIST myElement %a.global;
                    another CDATA #IMPLIED &gt;</q>
since the attribute list  for <code>&lt;myElement&gt;</code> will now be
understood to contain whatever list of attribute definitions was
declared as the value for the parameter entity <ident type="pe">a.global</ident>, followed by the definition for an
attribute called <ident>another</ident>.</p>
<p>Moreover, if we wish to change the global attributes
or add another, all we need do is provide a new declaration for <ident type="pe">a.global</ident> in the DTD. We do not even need to modify
the existing declaration, but simply ensure that the new one precedes
the old one in the DTD being processed. This is because of one very significant aspect of entity
declarations not mentioned above: if a declaration is given for the
same entity more than once, then only the first declaration is
applicable. If, for example, an XML processor finds the following:
<q rend="eg">&lt;!ENTITY switch &quot;UP&quot;&gt; 
&lt;!-- several other declarations --&gt;
&lt;!ENTITY switch &quot;DOWN&quot;&gt;
&lt;!ENTITY switch &quot;SIDEWAYS&quot;&gt;
&lt;!-- .... --&gt;
The switch is &amp;switch;</q>
then the entity reference at the end (assumed to be inside a document)
will be resolved as the string &quot;UP&quot; because that is the first
declaration encountered. This rule applies equally to general entities
and parameter entities, and has important consequences for the TEI
scheme. The TEI document type declaration makes extensive use of parameter
entities to control the selection of different tag sets and to make it
easier to modify the TEI DTD.  Numerous examples of their use may
thus be found in chapter 3 of the TEI Guidelines. They are also used to
     control the behaviour of conditional marked sections, as further
     discussed in section <ptr target="SG-cond"/> below. </p></div></div>


<div id="SG17BIS"><head>Marked sections</head>
<p>It is occasionally necessary to mark some portion of an XML document for
special treatment.  Within the body of a document, it is often convenient to
   be able to mark some portion as containing XML markup which is to
   be ignored. Within a DTD, it is often
   convenient to mark certain parts to be included or
   excluded in specific circumstances. To deal with the former situation, XML defines a
   construct known as a <term>CDATA marked section</term>; to deal
   with the latter, a syntactically similar construct known as a
   <term>conditional marked section</term> may be used.</p>
<p>Most users of the TEI encoding scheme will never need to use marked
sections, and may safely skip the remainder of this discussion.
The TEI DTD makes extensive use of conditional marked sections,
   however, and this section
should be read carefully by anyone wishing to follow in
detail the discussions in chapter 3 of the TEI Guidelines.</p>

<div id="SG-cond"><head>CDATA marked section</head>
<p>A <code>CDATA</code> marked section is delimited by two rather arcane
 sequences of characters: its start is marked by the string
    <code>&lt;![CDATA[</code>, and its end by the string
    <code>]]&gt;</code>. Note that spaces are not permitted
    within either string. </p>

<p>Within a <code>CDATA</code> marked section any strings of characters which look
like XML tags or entity references will not be recognized as such by
the XML parser: they are thus a very useful way of including examples
of XML tagging within a document itself written in XML. For example:

<q rend="eg">&lt;p&gt;The &lt;gi&gt;term&lt;/gi&gt; element may be used to mark any
  technical term:
  &lt;eg&gt;&lt;![CDATA[
  This &lt;term&gt;recursion&lt;/term&gt; is giving me a headache.
  ]]&gt;&lt;/eg&gt;&lt;/p&gt;</q>
   </p>
<p>In this extract from a document describing the way that an XML
    element called <gi>term</gi> may be used, the cited example
    (tagged with a <gi>eg</gi> element) includes an instance of the
    <gi>term</gi> element which will not be recognised as such, but
    simply as a string of characters, because it is contained by a
    marked section.</p>
<p>A similar effect can be achieved by simply replacing the angle
    brackets by entity references, but this makes the text somewhat
    unreadable in its native XML form if the example is of any length:
<q rend="eg">&lt;p&gt;The &lt;gi&gt;term&lt;/gi&gt; element may be used to mark any
  technical term:
  &lt;eg&gt;
  This &amp;lt;term&gt;recursion&amp;lt;/term&gt; is giving me a headache.
  &lt;/eg&gt;&lt;/p&gt;
</q>
   </p>
  </div>

<div id="SG-cms"><head>Conditional marked section</head>

<p>The <code>CDATA</code> marked section is a special case of the more general
   <term>marked section</term> construct provided by SGML. The
   conditional marked section is another instance of its use. Within
   the body of a DTD (but not within the body of a document),<note place="foot">This restriction does not apply to SGML documents,
   which may employ conditional marked sections within the document
   instance. Such usage is not recommended where XML/SGML
   compatibility is a consideration.</note> two other kinds of
   marked section are possible: an <code>IGNORE</code> marked section,
   and an <code>INCLUDE</code> marked section. As the names suggest,
   material within an <code>IGNORE</code> marked section is ignored
   during processing, while material within an <code>INCLUDE</code>
   marked section is included. These can be used to include and
   exclude portions of a DTD selectively, so as to adjust it to
   relevant circumstances. </p>
<p>Suppose, for example, that we want to allow for
   poems which  contain either only stanzas, or only
   couplets. A content model to enforce this rule is easy to define,
   but it does require us to to declare both possibilities &#x2014; we
   must provide declarations for both <gi>stanza</gi> and
   <gi>line</gi> elements, even though in a given document we know
   that only one will appear. An alternative approach might be to
   provide two different declarations for <gi>poem</gi>, as follows:
<q rend="eg">&lt;![INCLUDE[
   &lt;!ELEMENT poem (stanza+)&gt; 
   &lt;!ELEMENT stanza (line+)&gt; 
]]&gt;
&lt;![IGNORE[
   &lt;!ELEMENT poem (couplet+)&gt; 
   &lt;!ELEMENT couplet (line,line)&gt; 
]]&gt;</q>

The first declaration here will be the one used, since it is within an
<code>INCLUDE</code> marked section. The second one will be ignored. To swap
around, we change <code>INCLUDE</code> to <code>IGNORE</code>, and vice-versa.</p>

<p>The literal keywords <code>INCLUDE</code> and <code>IGNORE</code>,
however, are not much use in adjusting a DTD or a document to a user's
requirements.  If modifying a DTD to match user requirements involves
editing the text manually (changing <code>IGNORE</code> to
<code>INCLUDE</code> as appropriate), it is probably just as easy to
add or delete the affected parts of the DTD directly. However,
 the
<code>IGNORE</code> and <code>INCLUDE</code> keywords need not be
given as literal values; they can also be represented by a parameter
entity reference.  </p>
 
<p>In the following example, we have replaced the keywords by
references to two parameter entities:

<q rend="eg">&lt;![%stanzas;[
   &lt;!ELEMENT poem (stanza+)&gt; 
   &lt;!ELEMENT stanza (line+)&gt; 
   &lt;!ENTITY couplets &quot;IGNORE&quot;&gt;
]]&gt;

&lt;![%couplets;[
   &lt;!ELEMENT poem (couplet+)&gt; 
   &lt;!ELEMENT couplet (line,line)&gt; 
]]&gt;</q>

The exact meaning of this will depend on the values of the parameter
entities <ident>stanzas</ident> and <ident>couplets</ident> when the
DTD is processed. When parameter entities are used in this way to
control marked sections in a DTD, the  DTD file must
contain default declarations for them.  If the user wishes to override
any of the
defaults, all that needs to be done is to supply a new declaration and
ensure that it will be processed before the existing default. The
easiest way of doing this is to supply it within a special part of the
DTD known as the <term>DTD subset</term>.<note place="foot">This is
explained in more detail in section <ptr target="SG182"/> below; the
key point for our present purposes is that declarations in the DTD
subset are always read before those in the external DTD file, and, as
mentioned above in section <ptr target="SG-pe"/>, the first
declaration of a given entity is the one which counts.</note></p>

<p>With the following default declarations, poems will consist only of
stanzas and the second set of declarations will be ignored:

<q rend="eg">&lt;!ENTITY % stanzas &quot;INCLUDE&quot;&gt;
&lt;![%stanzas;[
   &lt;!ELEMENT poem (stanza+)&gt; 
   &lt;!ELEMENT stanza (line+)&gt; 
   &lt;!ENTITY % couplets &quot;IGNORE&quot;&gt;
]]&gt;

&lt;!ENTITY % couplets &quot;INCLUDE&quot;&gt;
&lt;![%couplets;[
   &lt;!ELEMENT poem (couplet+)&gt; 
   &lt;!ELEMENT couplet (line,line)&gt; 
]]&gt;</q>

This works because, although there are two declarations for the
parameter entity <ident>couplets</ident>, only the first is
effective. It declares the parameter entity <ident>couplets</ident> to
have the value <code>IGNORE</code>, and so the declarations within the
second conditional marked section are ignored. Suppose however that a
declaration for <ident>stanzas</ident> giving it the value
<code>IGNORE</code> were processed before this part of the DTD. In
that event, only the second declaration for the entity
<ident>couplets</ident> would be effective, since all the declarations
within the conditional marked section governed by
<ident>stanzas</ident> would be ignored. </p>

<p>Variations on this technique are used to control how the various
parts of a TEI DTD are constructed. For example:
 
<q rend="eg"> &lt;!ENTITY % TEI.prose 'INCLUDE'&gt;
 &lt;!ENTITY % TEI.extensions.dtd SYSTEM 'mystuff.dtd'&gt;</q>

These declarations have two effects: they activate a section of the
DTD containing declarations relevant to prose and they add into the
DTD whatever additional declarations are held in the external file
<ident>mystuff.dtd</ident>. In the standard DTD files, there is a
marked section controlled by the parameter entity <ident type="pe">TEI.prose</ident>, the default value of which is
<code>IGNORE</code>, and there is also a reference to the parameter
entity <ident type="pe">TEI.extensions.dtd</ident>, the default value
for which is the null string. The declarations cited above over-ride
both these defaults: the declarations within the marked section
controlled by the parameter entity <ident type="pe">TEI.prose</ident>
are thus made active; and the reference to the <ident type="pe">TEI.extensions.dtd</ident> parameter entity is replaced by
the content of the file <ident type="file">mystuff.dtd</ident>.</p></div></div>


<div><head>Other components of an XML document</head> <p>In addition
to the elements and entities so far discussed, an XML document can
contain a few other formally distinct things. An XML document may
contain arbitrary signals or flags for use when the document is
processed in a particular way by some class of processor: a common
example in document production is the need to force a formatter to
start a new page at some specific point in a document: such flags are
called <term>processing instructions</term>. An XML document may also
contain instances of elements which are defined in some other DTD than
the one declared in its <code>DOCTYPE</code> declaration, or (more generally) from
some other <term>namespace</term>. </p>

<div id="SG-pi"><head>Processing instructions</head>
<p>Although one of the aims of using XML is to remove any information
specific to the processing of a document from the document itself, it
is occasionally very convenient to be able to include such information
&#x2014; if only so that it can be clearly distinguished from the
structure of the document. As suggested above, one common example is
the need, when processing an XML document for printed output, to
include a suggestion that the formatting processor might use to
determine where to begin a new page of output. Page-breaking decisions
are usually best made by the formatting engine alone, but there will
always be occasions when it may be necessary to over-ride these. An XML
processing instruction inserted into the document is one very simple
and effective way of doing this without interfering with other aspects
of the markup.</p>
<p>Here is an example XML processing instruction:

<q rend="eg">&lt;?tex \newpage ?&gt;</q>

It begins with <code>&lt;?</code> and
ends  with <code>?&gt;</code>. In between are two space-separated
strings: by convention, the first is the name of some processor (<code>tex</code> in
the above example) and the second is some data intended for the use of
that processor (in this case, the instruction to start a new
page). The only constraint placed by XML on the strings is that the
first one must be a valid XML name; the other can be any arbitrary
sequence of characters, not including 
the closing character-sequence <code>?&gt;</code>,
</p>
 </div>

<div id="SGname"><head>Namespaces</head>

<p>A valid XML document necessarily specifies the DTD in which its
constituent elements are defined. However, a well-formed XML document
is not required to specify its DTD &#x2014; indeed, it may not even have a
DTD; it would still be useful to indicate that the element names used
in it have some defined provenance. Furthermore, it might be desirable
to include in a document elements which are defined (possibly
differently) in different DTDs. A cabinet-maker's DTD might well
define an element called <gi>table</gi> with very different
characteristics from those of a documentalist's. </p>

<p>The concept of <term>namespace</term> was introduced into the XML
language as a means of addressing these and related problems. If an
XML document is thought of as an expression in some language, then a
namespace may be thought of as analogous to the lexicon of that
language. Just as a document can contain words taken from different
languages, so a well-formed XML document can include elements taken
from different namespaces. Note however that because a document can
only specify a single DTD, elements which belong to namespaces other
than that defined by the DTD will appear to be illegal to a simple XML
validator: documents which use namespaces require special handling by
such processors. Like a DTD, a namespace contains a list of valid element
names; unlike a DTD, a namespace also has a distinctive
<term>prefix</term> and  an identifying <term>name</term>. </p>

<p>Suppose for example that we wish to extend our simple verse DTD to
include markup of wordclass information such as
<soCalled>noun</soCalled>, <soCalled>verb</soCalled>, etc. Suppose
further that a DTD already exists in which all the tags we wish to use
have been defined. We could (of course) simply combine the two DTDs to
form a new one, but this may not be practicable: for example, there
might be an element defined with the same name but different meanings
in each DTD. Instead, we supply the <term>prefix</term> associated
with the grammatical DTD's namespace (<code>gram</code>, for example) on each
element which is taken from that namespace, as in the following
example:

<q rend="eg">&lt;line xmlns:gram=&quot;http://www.gram.org&quot;&gt;
      &lt;gram:aux&gt;Shall&lt;/gram:aux&gt;
      &lt;gram:pron&gt;I&lt;/gram:pron&gt;
      &lt;gram:verb&gt;compare&lt;/gram:verb&gt;
      &lt;gram:pron&gt;thee&lt;/gram:pron&gt;
      &lt;gram:prep&gt;to&lt;/gram:prep&gt;
      &lt;gram:art&gt;a&lt;/gram:art&gt;
      &lt;gram:noun&gt;summer&lt;/gram:noun&gt;
      's
      &lt;gram:noun&gt;day&lt;/gram:noun&gt;
      ?
&lt;/line&gt;</q>
</p>

<p>In this example, the elements <gi>aux</gi>, <gi>pron</gi> etc. are
understood to be taken from a namespace named
<code>http://www.gram.org</code>, which uses the prefix
<code>gram</code>, as indicated by the special purpose attribute
<ident>xmlns:gram</ident>. The element <gi>line</gi> (and the two untagged
<code>#PCDATA</code> fragments it contains) however are in no particular
namespace. We could specify that they belong, by default, to the TEI
namespace by supplying a default namespace declaration, as follows:

<q rend="eg">&lt;line xmlns=&quot;http://www.tei-c.org&quot;      
      xmlns:gram=&quot;http://www.gram.org&quot;&gt;
      &lt;gram:aux&gt;Shall&lt;/gram:aux&gt;
      &lt;gram:pron&gt;I&lt;/gram:pron&gt;
      &lt;gram:verb&gt;compare&lt;/gram:verb&gt;
      &lt;gram:pron&gt;thee&lt;/gram:pron&gt;
      &lt;gram:prep&gt;to&lt;/gram:prep&gt;
      &lt;gram:art&gt;a&lt;/gram:art&gt;
      &lt;gram:noun&gt;summer&lt;/gram:noun&gt;
      's
      &lt;gram:noun&gt;day&lt;/gram:noun&gt;
      ?
&lt;/line&gt;</q>
</p>
<p>As shown here, an XML
document may have one default namespace declaration, and also any
number of other namespace declarations.  The scope of a namespace
declaration is the element on which it is declared: in the example
above, both the default TEI namespace and the additional gram
namespace apply to all elements in the document since they are declared on the
root element. In the following example, the gram namespace is
available only within the <gi>body</gi> element, while the TEI
namespace remains the default for the whole document:
<q rend="eg">&lt;text xmlns=&quot;http://www.tei-c.org&quot;&gt;
  &lt;front&gt;
    &lt;!-- gram prefix not available here --&gt;
  &lt;/front&gt;
  &lt;body xmlns:gram=&quot;http://www.gram.org&quot;&gt;
    &lt;!-- gram prefix is available here --&gt;
  &lt;/body&gt;
&lt;/text&gt;</q></p>
 </div>
</div>



<div id="SG18"><head>Putting it all together</head>
<p>An XML conformant document has a number of parts, not all of which
have been discussed in this chapter, and many of which the user of these
Guidelines may safely ignore.  For completeness, the following summary
of how the parts are inter-related may however be found useful.</p>
<p>An XML document consists of a  <term>prolog</term> and a
<term>document instance</term>.  The prolog contains an <term>XML
declaration</term> (described below)
and (optionally) a <term>document type declaration</term>, which
contains element and entity declarations such as those described above.
Different software systems may provide different ways of associating the
document instance with the prolog; in some cases, for example, the
prolog may be <soCalled>hard-wired</soCalled> into the software used, so that it is
completely invisible to the user.</p>

<div id="SG181"><head>SGML and XML declarations</head>
<p>As noted above, SGML allows for variation in several aspects of the dialect of SGML
being used such as the character set, the codes used for SGML
delimiters, the length of identifiers, etc.  These variations are
defined by a special additional document known as the <term>SGML
Declaration</term> prefixed to an SGML document, implicitly or
explicitly. Its content for
TEI-conformant document types is discussed further in chapters 39 of the TEI Guidelines and 28 of the TEI Guidelines.</p>
<p>All XML documents use the same SGML declaration, and it is therefore
erroneous to supply one. The only aspect of an XML document which may
vary is the external character encoding used, which is specified by
the <ident>encoding</ident> parameter on an initial <term>XML
declaration</term>. This looks syntactically like a processing
instruction (<ptr target="SG-pi"/>):
<q rend="eg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;</q>
but is generally regarded as a special kind of declaration. If
supplied, the XML declaration must be the first thing found in an XML
document. It can specify the version number of the XML Recommendation
applicable to the document it introduces (in this case, version 1.0),
and additionally the character encoding used to represent the Unicode
characters within it. In this case, the 16 bit characters of Unicode have been
mapped to the 8 bit character set known as ISO 8859-1; any characters
present in the document but not available in the target character set
will be represented as character entity references (<ptr target="SG-cer"/>).   </p>
</div>

<div id="SG182"><head>The <code>DOCTYPE</code> declaration</head>

<p>An XML file which is valid (as opposed to simply well-formed) must
    specify a DTD against which its content is to be validated. This
    is the function of the <code>DOCTYPE</code> declaration. </p>

<p>The <code>DOCTYPE</code> declaration contains, following the
    <code>DOCTYPE</code> keyword, at least two parts: the name of the
    root element for the associated document, and a set of
    declarations for all the elements, attributes, notations,
    entities, etc. which together define the document type declaration
    (DTD) of that document. Note, incidentally, that the root element
    name (and hence the <code>DOCTYPE</code> name) may be that of any
    element whose declaration is supplied in this set. The
    declarations may be supplied explicitly, or by reference to an
    external entity such as a file, or by a combination of the two.
    </p>

<p>Taking each of these possibilities in turn, we first present a
    <code>DOCTYPE</code> declaration in which the declarations for all the
    elements, attributes, etc. required are given explicitly:
 
<q rend="eg">&lt;!DOCTYPE myDoc [
  &lt;!ELEMENT myDoc (p+) &gt;
  &lt;!ATTLIST myDoc n CDATA #IMPLIED&gt;
  &lt;!ELEMENT p (#PCDATA)&gt;
]&gt;
&lt;myDoc n=&quot;1&quot;&gt;
  &lt;p&gt;This is an instance of a &quot;my.doc&quot; document&lt;/p&gt;
&lt;/myDoc&gt;</q>
Note that the required declarations are enclosed within square
    brackets inside the <code>DOCTYPE</code> declaration: this part of the
    declaration is technically known
    as the <term>DTD subset</term>. </p>

<p>More usually, however, the required  declarations  will be held in a
separate entity and invoked by reference, as follows:
 
<q rend="eg">&lt;!DOCTYPE myDoc SYSTEM &quot;myDoc.dtd&quot; []&gt;
&lt;myDoc&gt;
  &lt;p&gt;This is another instance of a &quot;myDoc&quot; document.&lt;/p&gt;
  &lt;p&gt;It has two paragraphs.&lt;/p&gt;
&lt;/myDoc&gt;</q>
 
Note the similarity between the syntax used to reference the external
entity containing the required declarations and that used to define
any other system entity (see <ptr target="SG-ents"/>). The square
brackets may be supplied even though they enclose nothing, as in this
example, or they may be omitted.</p>

<p>Next, we present a case where declarations are given both within
    the DTD subset and by reference to an external entity:
 
<q rend="eg">
&lt;!DOCTYPE myDoc SYSTEM &quot;myDoc.dtd&quot; [
  &lt;!ENTITY tla &quot;three letter acronym&quot;&gt;]&gt;
&lt;myDoc&gt;
  &lt;p&gt;This is yet another instance of a &quot;myDoc&quot; document.&lt;/p&gt;
  &lt;p&gt;It is surprisingly free of &amp;tla;s.&lt;/p&gt;
&lt;/myDoc&gt;</q>
</p>

<p>Any kind of declaration may be added to a DTD subset; as we have
already seen (<ptr target="SG-cms"/>), this is the mechanism by which the TEI DTD is
customized. 

<q rend="eg">
&lt;!DOCTYPE TEI.2 PUBLIC &quot;-//TEI P3//DTD Main Document Type//EN&quot; &quot;tei2.dtd&quot; [
  &lt;!ENTITY % TEI.prose 'INCLUDE'&gt;
  &lt;!ENTITY % TEI.XML   'INCLUDE'&gt;
  &lt;!ENTITY tla &quot;Three Letter Acronym&quot;&gt;
  &lt;!ENTITY % x.phrase  'myTag|'&gt;	 
  &lt;!ELEMENT myTag (#PCDATA)    &gt;
  &lt;!-- any other special-purpose declarations or
       re-declarations go  here --&gt;
  ]&gt;
&lt;TEI.2&gt;
  &lt;!-- This is an instance of a modified TEI.2 type document, which
       may contain &lt;myTag&gt;my special tags&lt;/myTag&gt; and references 
       to my usual entities such as &amp;tla;. --&gt;
&lt;/TEI.2&gt;</q>

When, as here, the document type declaration in force includes both
the contents of the DTD subset, and the contents of some external
entity (in the case above, whatever file is
specified by the <code>PUBLIC</code> identifier given, <ident>tei2.dtd</ident> by
default), declarations in the DTD subset are always carried out first.  As noted above, (<ptr target="SG-pe"/>), the order is
important, because in XML only the first declaration of an entity
counts.  In the above example, therefore, the declaration of the
entity <ident type="ent">tla</ident> in the DTD subset takes
precedence over any declaration of the same entity in the file <ident type="file">tei2.dtd</ident>.  Similarly, the declaration for
<ident type="pe">x.phrase</ident> takes precedence over the existing
declaration for that entity in the TEI dtd. It is perfectly legal for entities to
be declared more than once; elements, by
contrast, may not be declared more than once; if a declaration for
<gi>myTag</gi> were already contained in file <ident type="file">tei.dtd</ident>, the XML parser would signal an
error.</p></div>

<div id="SG183"><head>The Document Instance</head>
<p>The document instance is the content of the document itself.  It
contains only text, markup, and entity references, and thus may
not contain any new declarations.



 
A convenient way of building up large documents in a modular fashion
might be to use the DTD subset to declare entities for the individual
pieces or modules, thus:
 
<q rend="eg">
&lt;!DOCTYPE TEI.2 
          PUBLIC &quot;-//TEI P3//DTD Main Document Type//EN&quot;
		         &quot;tei2.dtd&quot; [
   &lt;!ENTITY % TEI.prose &quot;INCLUDE&quot;&gt;
   &lt;!ENTITY % TEI.XML &quot;INCLUDE&quot;&gt;
   &lt;!ENTITY chap1 SYSTEM &quot;chap1.txt&quot;&gt;
   &lt;!ENTITY chap2 SYSTEM &quot;chap2.txt&quot;&gt;
   &lt;!ENTITY chap3 &quot;-- not yet written --&quot;&gt;
   ]&gt;
&lt;TEI.2&gt;
  &lt;teiHeader&gt; &lt;!-- ... --&gt; &lt;/teiHeader&gt;
    &lt;text&gt;
      &lt;body&gt;
        &amp;chap1;
        &amp;chap2;
        &amp;chap3;
        &lt;!-- ... --&gt;
     &lt;/body&gt;
  &lt;/text&gt;
&lt;/TEI.2&gt;</q></p>

<p>In this example, the TEI DTD 
has been extended by entity declarations
for each chapter of some document.  The first two are external entities
referring to the file in which the text of particular chapters is to
be found; the third a dummy, indicating that the text does not yet
exist (alternatively, an entity with a null value could be used).  In
the document instance, the entity references <code>&amp;chap1;</code> etc. will
be resolved by the parser to give the required contents.  The chapter
files themselves will not, of course, contain any element, attribute
list, or entity declarations &#x2013; just tagged text.</p></div>

<div id="SGPATANC"><head>Ancillary Files</head>

<p>A working XML system is likely to use a number of ancillary files
to hold configuration information.  These may include stylesheets, 
specialized processing instructions,  collections of relevant entity
declarations, setup information for specific programs, and many other components. In general, the ways in which such components are to be
assembled or configured vary with the system and cannot readily be
described here.</p>

<p>To assist in this process many systems take advantage of an
additional <term>catalog file</term>, the chief function of which is
to associate the formal public identifiers used in a document or DTD
with specific system entities, over-riding any default
association. One widely used format for such catalog files was
defined by an industry group originally known as SGML Open, and such
files are therefore known as SGML Open catalogs, even though they may
also be used by XML processors. The group has more recently redefined
itself under the name of the Organization for the Advancement of
Structured Information Standards (OASIS), and in August 2001 published
a specification for catalog files in XML form. <note place="foot">The
SGML Open catalog format is documented in <bibl>SGML Open Technical
Resolution 9401:1997, <title>Entity Management</title></bibl>, which
is available from <xptr doc="EntManage"/>; the XML Catalog
specification, also produced by OASIS is available from their site at
<xptr doc="EntManageX"/>.</note> Catalog files in both SGML Open and
XML formats are distributed along with the current TEI DTD.  See
chapter 36 of the TEI Guidelines for more information.</p>

</div></div>





</div>
</body>
</text>
</TEI.2>
